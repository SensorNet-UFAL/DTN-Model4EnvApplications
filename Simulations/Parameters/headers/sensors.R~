# http://www.leg.ufpr.br/geoR/geoRdoc/geoRintro.html

# install.packages("spatstat","RandomFields","igraph","geoR","Hmisc","plotrix","HH","ads","spdep","deldir","hash",dep=TRUE)

library(spatstat)
library(RandomFields)
library(geoR)
library("spdep")
library(hash)

library(compiler)
enableJIT(3)

#Gera campos gaussianos. Parametros -> media variancia nugget phi kappa
gaussianFields <- function(fileName='new', x=(0:99), y=(0:99), model='whittlematern', param=c(100,10,1,5,2))
{
        gF <- RFsimulate(x=x, y=y, model=model, grid=TRUE, param=param)
        #write.table(gF, file=paste('GRF/GaussianField-',fileName,'.dat',sep=''))
        return(gF)
}

mygrf <- function(kappa,phi,mean,var,nugget)
{
	cov.pars = c(var,phi)
	cov.model = "matern"
	nsim = 1
	assign("setRF", geoR2RF(cov.model = cov.model, cov.pars = cov.pars, nugget = nugget, kappa = kappa ), pos = 1)
	return(matrix(grf(nx=100,ny=100,n=100^2,xlims=c(0,99),ylims=c(0,99), nugget=nugget,mean=mean,cov.pars=cov.pars,kappa=kappa,grid="reg")$data,ncol=100))

}
#Leitura dos dados sensoreados
# Coleta de informação dos sensores no campo, levando em 
# consideração um raio de cobertura
# retorna a integral dos valores observados
readData <- function(sensores, campo, raio=10)
{
  if(missing(sensores)) stop('Falta sensores')
  if(missing(campo)) stop('Falta o campo gaussiano')
  data <- c()
  
  # Para cada sensor, faz a coleta de informação
  for(s in 1:sensores$n)
  {
    # inf -> inferior sup -> superior no caso do disco
    x <- trunc(sensores$x[s])
    y <- trunc(sensores$y[s])
    x_inf <- x - raio
    x_sup <- x + raio
    y_inf <- y - raio
    y_sup <- y + raio
    
    # Ajustando os valores 
    if(x == 0) x <- 1
    if(y == 0) y <- 1
    if(x_inf <= 0) x_inf <- 1
    if(y_inf <= 0) y_inf <- 1
    if(x_sup > 100) x_sup <- 100
    if(y_sup > 100) y_sup <- 100
    
    #print(paste("X e Y ",x," ",y))
    
    #Quantidade de pixels
    quant <- 0
    temp <- 0
    
    # data recebe a integral do campo sobre o disco(x,y,raio)
    for(i in x_inf:x_sup)
      for(j in y_inf:y_sup)
        if((i-x)^2 + (j-y)^2 <= raio^2)
        {
          #print(paste("X e Y ",x," ",y," I e J: ",i," ",j))
          temp <- temp + campo[i,j]
          quant <- quant + 1
        }
    data[s] <- temp/quant
  }
  
  return(data)
}
#Leitura dos dados sensoreados
# Coleta de informação dos sensores no campo, levando em 
# consideração um raio de cobertura
# retorna a integral dos valores observados
readDataHash <- function(sensores, campo, raio=10)
{
  if(missing(sensores)) stop('Falta sensores')
  if(missing(campo)) stop('Falta o campo gaussiano')
  data <- hash()
  
  # Para cada sensor, faz a coleta de informação
  for(s in 1:sensores$n)
  {
    # inf -> inferior sup -> superior no caso do disco
    x <- trunc(sensores$x[s])
    y <- trunc(sensores$y[s])
    x_inf <- x - raio
    x_sup <- x + raio
    y_inf <- y - raio
    y_sup <- y + raio
    
    # Ajustando os valores 
    if(x == 0) x <- 1
    if(y == 0) y <- 1
    if(x_inf <= 0) x_inf <- 1
    if(y_inf <= 0) y_inf <- 1
    if(x_sup > 100) x_sup <- 100
    if(y_sup > 100) y_sup <- 100
    
    #print(paste("X e Y ",x," ",y))
    
    #Quantidade de pixels
    quant <- 0
    temp <- 0
    
    # data recebe os dados sobre o disco(x,y,raio)
    data_ <- matrix(nrow=0,ncol=3)
    for(i in x_inf:x_sup)
      for(j in y_inf:y_sup)
        if((i-x)^2 + (j-y)^2 <= raio^2)
        {
          #print(paste("X e Y ",x," ",y," I e J: ",i," ",j))
#           temp <- temp + campo[i,j]
#           quant <- quant + 1
          data_ <- rbind(data_, c(i,j,campo[i,j]))
        }
    data[s] <- as.geodata(data_);
    
#     # Atribuição dos valores do conjunto de dados para cada sensor.
#     for(s in 1:sensores$n){
#       # Contagem da # de elementos que cada sensor é responsável.
#       data_ <- matrix(nrow=0,ncol=3) 
#       count = 0
#       for(i in 1:100)
#         for(j in 1:100)
#           if(saux[i,j] == s){
#             data_ <- rbind(data_, c(i,j,campo[i,j]))
#           }
#       data[s] <- as.geodata(data_);
#     }
#     
    
  }
  
  return(data)
}

#Leitura dos dados sensoreados - By Alla
# Coleta de informação dos sensores no campo, levando em 
# consideração um raio de cobertura
# retorna todos os valores observados

# Obs.: Formato da hash: [k,x] onde k = "1", "2"...
readDataVoronoi <- function(sensores, campo) {
	if(missing(sensores)) stop('Falta sensores')
	if(missing(campo)) stop('Falta o campo gaussiano')
	data <- hash()

  # Matriz que registra a região onde cada sensor é responsável no diagrama de Voronoi.
	saux <- matrix(nrow = 100, ncol = 100)
	quant <- 1
	for(i in 1:100){
	  for(j in 1:100){
	    dist = 99999;
	    for(s in 1:sensores$n){
	      x <- trunc(sensores$x[s])
	      y <- trunc(sensores$y[s])
        	aux = sqrt((i-x)^2 + (j-y)^2)
		if(aux < dist){
          		saux[i,j] <- s
          		dist = aux
		}
	    }
	  }

	cat('\r',format(paste("Building Voronoi Diagram: ",i, "%", sep='')))
	flush.console() 
	}
  
  # Atribuição dos valores do conjunto de dados para cada sensor.
	for(s in 1:sensores$n){
    # Contagem da # de elementos que cada sensor é responsável.
		data_ <- matrix(nrow=0,ncol=3) 
    		count = 0
		it = 0
    		for(i in 1:100) {
	    		for(j in 1:100) {
				      it = it + 1
	      			if(saux[i,j] == s){
          					data_ <- rbind(data_, c(i,j,campo[i,j]))
	      			}
			}
		}
	#print(data_)
	  data[s] <- as.geodata(data_)
	}

	return(data)
}

#Leitura dos dados sensoreados (clusterheads)
readDataCH <- function(sensores, clusters, campo, raio=10, flag)
{
	if(missing(sensores)) stop('Falta sensores')
	if(missing(clusters)) stop('Falta clusters')
	if(missing(campo)) stop('Falta Campo')
	data <- as.numeric()
	cl <- length(clusters)
        
	# Para cada Cluster
	for(n in 1:cl)
	{
		dataP <- as.numeric()
		
		# Para cada sensore no cluster n
		for(s in clusters[[n]])
		{
			x <- trunc(sensores$x[s])
			y <- trunc(sensores$y[s])
			x_inf <- x - raio
			x_sup <- x + raio
			y_inf <- y - raio
			y_sup <- y + raio
			
			        
			if(x == 0) x <- 1
			if(y == 0) y <- 1
			if(x_inf <= 0) x_inf <- 1
			if(y_inf <= 0) y_inf <- 1
			if(x_sup > 100) x_sup <- 100
			if(y_sup > 100) y_sup <- 100
                       
			quant <- 0
			temp <- 0
                       
			# data recebe a integral do campo sobre o disco(x,y,raio)
			for(i in x_inf:x_sup)
				for(j in y_inf:y_sup)
					if((i-x)^2 + (j-y)^2 <= raio^2)
					{
						temp <- temp + campo[x,y]
                       	quant <- quant + 1
					}
			dataP[length(dataP)+1] <- temp/quant
		}
		    
		if(flag == 1) 
		{
			data[n] <- mean(dataP)
		} else if(flag == 2) 
		{
			data[n] <- median(dataP)
		} else if(flag == 3)
		{
			x = sort(dataP)
			y = x[ceiling(length(x)/4):ceiling(3*length(x)/4)]
			data[n] <- mean(y)
		}
	}
	return(data)
}

#Converte para a classe geodata
geo <- function(sensors, data)
{
        if(missing(sensors)) stop('Missing sensors')
        if(missing(data)) stop("Missing sensors' data")
        if(sensors$n != length(data)) stop('#sensors not equal to #data')
        g <- matrix(nrow=sensors$n, ncol=3)
        g[,1] <- sensors$x
        g[,2] <- sensors$y
        g[,3] <- data
        return(as.geodata(g))
}

#Converte para a classe geodata (clusterheads)
geoCH <- function(sensors, clusters, data)
{
        if(missing(sensors)) stop('Missing sensors')
        if(missing(data)) stop("Missing sensors' data")
        cl <- length(clusters)
        if(cl != length(data)) stop('#clusters not equal to #data')
        g <- matrix(nrow=cl, ncol=3)
        for(s in 1:cl)
        {
		        g[s,1] <- sensors$x[clusters[[s]][1]]
                g[s,2] <- sensors$y[clusters[[s]][1]]
        }
        g[,3] <- data
        return(as.geodata(g))
}

#Recosntrucao por kriging simples
simpleKriging <- function(geoData, file='new', covModel='matern', beta)
{
        if(missing(geoData)) stop('Missing geodata')
        locs <- pred_grid(c(0,99), c(0,99), by=1)
	      ml <- likfit(geoData, ini=c(20,10), cov.model="matern",fix.kappa=FALSE,kappa=2,nugget=0,fix.nugget=TRUE)
        KC <- krige.control(type='sk', obj.mod=ml)
        sk <- krige.conv(geoData, krige=KC, loc=locs)
        
        saida = list()
        saida$kappa = ml$kappa
        saida$phi = ml$phi
        saida$predict = sk$predict
        return(saida)
}

#Recosntrucao por kriging ordinario
ordinaryKriging <- function(geoData, file='new', covModel='matern')
{
        if(missing(geoData)) stop('Missing geodata')
        dup <- dup.coords(geoData$coords)
        while(!is.null(dup))
        {
                coords <- matrix(ncol=2, nrow=(dim(geoData$coords)[1]-1))
                Data <- as.numeric()
                if(dup[1,1] > 1)
                {
                        coords[1:(dup[1,1]-1),] <- geoData$coords[1:(dup[1,1]-1),]
                        Data[1:(dup[1,1]-1)] <- geoData$data[1:(dup[1,1]-1)]
                }
                m <- length(geoData$data)
                if(dup[1,1] < m)
                {
                        coords[(dup[1,1]):(m-1),] <- geoData$coords[(dup[1,1]+1):m,]
                        Data[(dup[1,1]):(m-1)] <- geoData$data[(dup[1,1]+1):m]
                }
                g <- matrix(ncol=3, nrow=(m-1))
                g[,1:2] <- coords
                g[,3] <- Data
                geoData <- as.geodata(g)
                dup <- dup.coords(geoData$coords)
        }
        locs <- pred_grid(c(0,99), c(0,99), by=1)
        ini.vals <- expand.grid(0:99, 0:99)
        variogram <- variog(geoData)
        v <- variofit(variogram, ini=ini.vals, fix.nugget=TRUE)
        KC <- krige.control(type='ok', obj.mod=v)
        ok <- krige.conv(geoData, krige=KC, loc=locs)
        #write.table(ok$predict, file=paste('kriging/ordinary_kriging-predict-',file,'-cov=',covModel,'.dat',sep=''))
        #write.table(v$kappa, file=paste('kriging/ordinary_kriging-kappa-',file,'-cov=',covModel,'.dat',sep=''))
        #write.table(v$cov.pars[2], file=paste('kriging/ordinary_kriging-cov.pars-',file,'-cov=',covModel,'.dat',sep=''))
        
        saida = list()
        saida$kappa = v$kappa
        saida$phi = v$cov.pars[2] # É phi segundo o Bruno
        saida$predict = ok$predict
}

# Medida de avaliação de erro
erro <- function(predict,campo)
{
	erro = 0
	for(i in 1:100)
		for(j in 1:100)
		{
			erro = erro + abs((campo[i,j] - predict[i,j])/ campo[i,j])
		}
	erro = erro / 10000
	return(erro)
}

#Recosntrucao por kriging bayesiano
bayesianKriging <- function(geoData, file='new', corModel='matern', beta)
{
        if(missing(geoData)) stop('Missing geodata')
        dup <- dup.coords(geoData$coords)
        while(!is.null(dup))
        {
                coords <- matrix(ncol=2, nrow=(dim(geoData$coords)[1]-1))
                Data <- as.numeric()
                if(dup[1,1] > 1)
                {
                        coords[1:(dup[1,1]-1),] <- geoData$coords[1:(dup[1,1]-1),]
                        Data[1:(dup[1,1]-1)] <- geoData$data[1:(dup[1,1]-1)]
                }
                m <- length(geoData$data)
                if(dup[1,1] < m)
                {
                        coords[(dup[1,1]):(m-1),] <- geoData$coords[(dup[1,1]+1):m,]
                        Data[(dup[1,1]):(m-1)] <- geoData$data[(dup[1,1]+1):m]
                }
                g <- matrix(ncol=3, nrow=(m-1))
                g[,1:2] <- coords
                g[,3] <- Data
                geoData <- as.geodata(g)
                dup <- dup.coords(geoData$coords)
        }
        locs <- expand.grid((0:99), (0:99))
        BC <- model.control(cov.model=corModel)
        if(missing(beta))
        {
                bk <- krige.bayes(geoData, model=BC, locations=locs)
        }
        else
        {
                BP <- prior.control(beta=beta)
                bk <- krige.bayes(geoData, model=BC, prior=BP, locations=locs)
        }
        values <- .values.krige.bayes(bk, messages.screen=F, values.to.plot=1)
        write.table(values, file=paste('kriging/bayesian_kriging-predict-',file,'-cov=',corModel,'.dat',sep=''))
        write.table(bk$model$kappa, file=paste('kriging/bayesian_kriging-kappa-',file,'-cov=',corModel,'.dat',sep=''))
        write.table(bk$prior$phi$phi.marginal, file=paste('kriging/bayesian_kriging-phi-',file,'-cov=',corModel,'.dat',sep=''))
        if(missing(beta)) write.table(bk$posterior$beta$summary[[1]], file=paste('kriging/bayesian_kriging-beta-',file,'-cov=',corModel,'.dat',sep=''))
}

#Recosntrucao por kriging
kriging <- function(gd, fileName, covModel, gf)
{
        ml <- simpleKriging(gd, file=paste('mean-GLS-',fileName,sep=''), covModel)
        simpleKriging(gd, file=paste('mean-OLS-',fileName,sep=''), covModel, beta=mean(gd$data))
        simpleKriging(gd, file=paste('mean-CTE-',fileName,sep=''), covModel, beta=mean(gf))
        ordinaryKriging(gd, file=fileName, covModel)
        bayesianKriging(gd, file=fileName, covModel)
        bayesianKriging(gd, file=paste('mean-GLS-',fileName,sep=''), covModel, beta=ml$beta)
}

#Agrupamentos
clusterReconstruction <- function(sensors, fileName, covModel, gf, ratio, nClusters)
{
        gd <- geo(sensors, readData(sensors, gf))
        clustersLeach <- leachClustering(sensors, ratio, nClusters)
        clustersSkater <- skaterClustering(sensors, ratio, nClusters, readData(sensors, gf))
        kriging(gd, fileName=paste('noClustering-',fileName,sep=''), covModel, gf)
        kriging(geoCH(sensors, clustersLeach, readDataCH(sensors, clustersLeach, gf)), fileName=paste('leach-',fileName,sep=''), covModel, gf)
        kriging(geoCH(sensors, clustersSkater, readDataCH(sensors, clustersSkater, gf)), fileName=paste('skater-',fileName,sep=''), covModel, gf)
}

simulation <- function(nSensors=50, ratio=20, nClusters=5, model='matern', cov='whittlematern',attraction, mean, variance, kappa, phi, scale, nugget, rep=1, seed=123)
{
        set.seed(seed)
        for(me in mean)
        {
                for(v in variance)
                {
                        for(p in phi)
                        {
                                for(k in kappa)
                                {
                                        gf <- gaussianFields(fileName=paste('model=',cov,'-param=(',me,',',v,',',nugget,',',p,',',k,')-run=',seed,sep=''), model=cov, param=c(me,v,nugget,p,k))
                                        for(at in attraction)
                                        {
                                                sensors <- m2p2(numsensores=nSensors, pp=at)
                                                clusterReconstruction(sensors, fileName=paste('run=',seed,'-alpha=',at,'-param=(',me,',',v,',',nugget,',',p,',',k,')',sep=''), model, gf, ratio, nClusters)
                                        }
                                }
                        }
                }
        }
}



#####################################################################################################

image.kriging <- function (x, locations, borders, values = x$predict, coords.data, x.leg, y.leg, ...) 
{
        op <- par(no.readonly = TRUE)
        on.exit(par(op))
        ldots <- match.call(expand.dots = FALSE)$...
        if (missing(x)) 
                x <- NULL
        attach(x, pos = 2, warn.conflicts = FALSE)
        on.exit(detach(2))
        if (missing(locations)) 
                locations <- eval(attr(x, "prediction.locations"), envir = attr(x, "parent.env"))
        if (is.null(locations)) 
                stop("prediction locations must be provided")
        if (ncol(locations) != 2) 
                stop("locations must be a matrix or data-frame with two columns")
        if (missing(borders))
        {
                if (!is.null(attr(x, "borders"))) 
                        borders.arg <- borders <- eval(attr(x, "borders"), envir = attr(x, "parent.env"))
                else borders.arg <- borders <- eval(x$call$geodata, envir = attr(x, "parent.env"))$borders
        }
        else {
                borders.arg <- borders
                if (is.null(borders)) 
                        borders <- eval(attr(x, "borders"), envir = attr(x, "parent.env"))
        }
        if (missing(coords.data)) 
                coords.data <- NULL
        else if (all(coords.data == TRUE)) 
                coords.data <- eval(attr(x, "data.locations"), envir = attr(x, "parent.env"))
        if (missing(x.leg)) 
                x.leg <- NULL
        if (missing(y.leg)) 
                y.leg <- NULL
        if (!is.null(attr(x, "sp.dim")) && attr(x, "sp.dim") == "1D")
        {
                do.call("plot.1d", c(list(x = values, x1vals = unique(round(locations[,1], dig = 12))), .ldots.set(ldots, type = "plot.1d", data = "prediction")))
        }
        else {
                ldots.image <- .ldots.set(ldots, type = "image", data = "prediction")
                locations <- .prepare.graph.kriging(locations = locations, 
                        borders = borders, borders.obj = eval(attr(x, "borders"), envir = attr(x, "parent.env")), values = values, xlim = ldots.image$xlim, ylim = ldots.image$yli)
                do.call("image", c(list(x = locations$x, y = locations$y, 
                        z = locations$values), ldots.image, axes=FALSE))
                if (!is.null(coords.data)) 
                        points(coords.data, pch = 20)
                if (!is.null(borders.arg)) 
                        polygon(borders, lwd = 2)
                if (!is.null(x.leg) & !is.null(y.leg)) {
                        do.call("legend.krige", c(list(x.leg = x.leg, y.leg = y.leg, values = locations$values[!is.na(locations$values)]), ldots))
                }
        }
        return(invisible())
}

image.krige.bayes <- function (x, locations, borders, values.to.plot = c("mean", "variance", "mean.simulations", "variance.simulations", "quantiles", "probabilities", "simulation"), number.col, coords.data, x.leg, y.leg, messages, ...) 
{
        borders <- NULL
    ldots <- match.call(expand.dots = FALSE)$...
    if (missing(x)) 
        x <- NULL
    attach(x, pos = 2, warn.conflicts = FALSE)
    on.exit(detach(2))
    if (missing(locations)) 
        locations <- eval(attr(x, "prediction.locations"), envir = attr(x, "parent.env"))
    if (is.null(locations)) 
        stop("prediction locations must be provided")
    if (ncol(locations) != 2) 
        stop("locations must be a matrix or data-frame with two columns")
    if (mode(values.to.plot) != "numeric") 
        values.to.plot <- match.arg(values.to.plot, choices = c("mean", "variance", "mean.simulations", "variance.simulations", "quantiles", "probabilities", "simulation"))
    if (missing(borders)) {
        if (!is.null(attr(x, "borders"))) 
            borders.arg <- borders <- eval(attr(x, "borders"), envir = attr(x, "parent.env"))
        else borders.arg <- borders <- eval(x$call$geodata, envir = attr(x, "parent.env"))$borders
    }
    else {
        borders.arg <- borders
        if (is.null(borders)) 
            borders <- eval(attr(x, "borders"), envir = attr(x, "parent.env"))
    }
    if (missing(number.col)) 
        number.col <- NULL
    if (missing(coords.data)) 
        coords.data <- NULL
    else if (all(coords.data == TRUE)) 
        coords.data <- eval(attr(x, "data.locations"), envir = attr(x, "parent.env"))
    if (missing(x.leg)) 
        x.leg <- NULL
    if (missing(y.leg)) 
        y.leg <- NULL
    if (!is.null(attr(x, "sp.dim")) && attr(x, "sp.dim") == "1D") {
        if (mode(values.to.plot) != "numeric") 
            values.to.plot <- .values.krige.bayes(obj = x, values.to.plot = values.to.plot, number.col = number.col, messages.screen = messages)
        do.call("plot.1d", c(list(x = list(coords = locations, data = values.to.plot), x1vals = unique(round(locations[, 1], dig = 12))), .ldots.set(ldots, type = "plot.1d", data = "prediction")))
    }
    else {
        ldots.image <- .ldots.set(ldots, type = "image", data = "prediction")
        locations <- .prepare.graph.krige.bayes(obj = x, locations = locations, borders = borders, borders.obj = eval(attr(x, "borders"), envir = attr(x, "parent.env")), values.to.plot = values.to.plot, number.col = number.col, xlim = ldots.image$xlim, ylim = ldots.image$ylim, messages = messages)
        do.call("image", c(list(x = locations$x, y = locations$y, z = locations$values), ldots.image, axes=F))
        if (!is.null(coords.data)) 
            points(coords.data)
        if (!is.null(borders.arg)) 
            polygon(borders, lwd = 2)
        if (is.null(ldots$col)) 
            ldots$col <- heat.colors(12)
        if (!is.null(x.leg) & !is.null(y.leg)) {
            do.call("legend.krige", c(list(x.leg = x.leg, y.leg = y.leg, values = locations$values), ldots))
        }
    }
    return(invisible())
}

