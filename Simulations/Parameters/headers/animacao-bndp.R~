source("algorithms.R")


BNDP <- function(allSensors_, bufferSize_, sensors, route, range) {

	newAllSensors <- DropLast(allSensors_, bufferSize_, route) # Na primeira etapa, o algoritmo executa o drop last

	newStartPoint <- dataStreamLength(newAllSensors)$qtdSensors #Aponta para o último índice atingido na amostragem inicial
	counter <- dataStreamLength(newAllSensors)$totalStreamLength #Contador para controlar o uso do buffer
	turnsWithoutDrop <- 0 # Variável para controle de rodadas sem descarte

	for(i in (newStartPoint+1):length(route)) { # Buffer cheio
		streamLength <- length(allSensors_[[route[i]]]$data) # Armazenando a quantidade de amostras
		#print(paste("Current Node:", route[i]))

		for(j in 1:streamLength) { # Obs.: A primeira iteraçao irá encher o buffer
			counter <- counter+1
			if(counter > bufferSize_)
				fullBuffer <- TRUE		
		}

		if(fullBuffer == FALSE) {
			newAllSensors[[route[i]]] <- allSensors_[[route[i]]] # Pega todos os dados de um nó
			#print(paste(route[i], "Received."))
			#print(paste("Buffer", counter))

		} else { # Se o buffer estiver cheio

			#print("Full buffer.")

			oldNewAllSensors <- length(names(newAllSensors)) # Variável para controle de rodadas sem descarte
			newAllSensors <- dropNeighbors(newAllSensors, sensors, range) # Redução baseada na vizinhança

			if(oldNewAllSensors ==  length(names(newAllSensors))) { # Checa se houve mudança no buffer
				turnsWithoutDrop <- turnsWithoutDrop + 1
			} else {
				turnsWithoutDrop <- 0
			}

			if(turnsWithoutDrop > ceiling(n_sensores/20)) { # Após um determinado tempo sem descartar nada, descartar o maior pacote
				newAllSensors <- dropBiggestStream(newAllSensors)
				turnsWithoutDrop <- 0
				#print("Drop the biggest pack.")
			}

			counter <- dataStreamLength(newAllSensors)$totalStreamLength # Atualizando o espaço ocupado no buffer
			#print(paste("Reduced Buffer:", counter))

			if((counter + streamLength) <= bufferSize_) {
				newAllSensors[[route[i]]] <- allSensors_[[route[i]]] # Pega todos os dados de um nó
				counter <- counter+streamLength # Atualizando o espaço ocupado no buffer
				fullBuffer = FALSE
				#print(paste(route[i], "Received."))
			}
		}

	plot_field(newAllSensors)

	}

	print(paste("Final buffer usage: ", counter))
	return(newAllSensors)
}

plot_field <- function(i,hashDadosSampled) {

    # Separação dos dados para gerar figura e para obter o kriging
    	dataToKrig = matrix(nrow=count, ncol = 3) # Dados para o krig
    	dadosSampled = matrix(nrow = maxY, ncol = maxX) # Dados para a figura
    	count = 1
    	for(s in 1:streamLength){
      		geoTemp = hashDadosSampled[[listNamesHash[s]]]
      		for(i in 1:length(geoTemp$data)){
        		dataToKrig[count,1] <- x_ <- geoTemp$coords[i,1]
        		dataToKrig[count,2] <- y_ <- geoTemp$coords[i,2]
        		dataToKrig[count,3] <- dadosSampled[x_,y_] <- geoTemp$data[i]
        		count = count + 1
      		}
    	}

	figName <- paste("it-",i,".eps", sep='')

	GerarFigura(i, dadosSampled)

}

